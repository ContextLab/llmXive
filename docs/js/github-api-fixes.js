// Fixes for GitHub API - Project Board Status Integration

// Enhanced status detection that checks both labels AND project board data
async function getEnhancedStatusFromIssue(issue) {
    // First try to get status from project board via GraphQL
    try {
        const projectBoardStatus = await getProjectBoardStatus(issue.number);
        if (projectBoardStatus && projectBoardStatus !== 'No Status') {
            return projectBoardStatus;
        }
    } catch (error) {
        console.warn('Could not fetch project board status:', error);
    }
    
    // Fallback to label-based detection
    return getStatusFromLabels(issue.labels);
}

// Fetch status from GitHub Project Board using GraphQL
async function getProjectBoardStatus(issueNumber) {
    const query = `
        query($owner: String!, $repo: String!, $number: Int!) {
            repository(owner: $owner, name: $repo) {
                issue(number: $number) {
                    projectItems(first: 10) {
                        nodes {
                            project {
                                title
                                number
                            }
                            fieldValues(first: 10) {
                                nodes {
                                    ... on ProjectV2ItemFieldSingleSelectValue {
                                        name
                                        field {
                                            ... on ProjectV2SingleSelectField {
                                                name
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    `;
    
    const variables = {
        owner: CONFIG.github.owner,
        repo: CONFIG.github.repo,
        number: issueNumber
    };
    
    const response = await fetch('https://api.github.com/graphql', {
        method: 'POST',
        headers: {
            'Authorization': `Bearer ${window.githubAuth?.token || ''}`,
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({ query, variables })
    });
    
    if (!response.ok) {
        throw new Error('GraphQL request failed');
    }
    
    const data = await response.json();
    const projectItems = data.data?.repository?.issue?.projectItems?.nodes || [];
    
    // Look for llmXive project (project #13)
    for (const item of projectItems) {
        if (item.project.number === 13) {
            // Find Status field value
            for (const fieldValue of item.fieldValues.nodes) {
                if (fieldValue.field?.name === 'Status') {
                    return fieldValue.name;
                }
            }
        }
    }
    
    return null;
}

// Enhanced author parsing from issue body and comments
function parseModelAuthor(issue) {
    const patterns = [
        // Pattern 1: "*Model: ModelName*" at end of issue body
        /\*Model:\s*([^*]+)\*/i,
        // Pattern 2: "Generated by ModelName" in issue body
        /Generated by\s+([^\n]+)/i,
        // Pattern 3: Attribution comment format
        /Model:\s*([^\n]+)/i,
        // Pattern 4: "This .* was .* generated by .* Model: xyz"
        /generated by.*Model:\s*([^\n]+)/i
    ];
    
    // Check issue body first
    if (issue.body) {
        for (const pattern of patterns) {
            const match = issue.body.match(pattern);
            if (match) {
                return cleanModelName(match[1]);
            }
        }
    }
    
    // If no model found in body, check first few comments for attribution
    // This would require fetching comments, so we'll mark it for async processing
    return null;
}

// Clean up model names
function cleanModelName(modelName) {
    return modelName
        .trim()
        .replace(/\s+/g, ' ')
        .replace(/[*_]/g, '')
        .split('/').pop(); // Get just the model name, not the full path
}

// Export the enhanced functions
window.githubAPIFixes = {
    getEnhancedStatusFromIssue,
    getProjectBoardStatus,
    parseModelAuthor,
    
    // Apply fixes to existing GitHubAPI class
    applyFixes(githubAPI) {
        // Override the getStatusFromLabels method
        const originalGetStatus = githubAPI.getStatusFromLabels.bind(githubAPI);
        
        githubAPI.getStatusFromLabels = function(labels) {
            // Still use original as fallback
            return originalGetStatus(labels);
        };
        
        // Override fetchIssues to include enhanced status
        const originalFetchIssues = githubAPI.fetchIssues.bind(githubAPI);
        
        githubAPI.fetchIssues = async function() {
            const issues = await originalFetchIssues();
            
            // Enhance each issue with project board status and model author
            const enhancedIssues = await Promise.all(
                issues.map(async (issue) => {
                    // Try to get project board status
                    let projectStatus = issue.projectStatus;
                    try {
                        const boardStatus = await getProjectBoardStatus(issue.number);
                        if (boardStatus) {
                            projectStatus = boardStatus;
                        }
                    } catch (error) {
                        console.debug('Using label-based status for issue', issue.number);
                    }
                    
                    // Parse model author
                    const modelAuthor = parseModelAuthor(issue);
                    
                    return {
                        ...issue,
                        projectStatus,
                        modelAuthor,
                        displayAuthor: modelAuthor || issue.user.login
                    };
                })
            );
            
            return enhancedIssues;
        };
    }
};