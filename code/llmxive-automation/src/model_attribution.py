"""Model attribution tracking for llmXive automation"""

import json
import os
from datetime import datetime
from typing import Dict, Any, Optional


class ModelAttributionTracker:
    """Track and attribute contributions to specific models"""
    
    def __init__(self, attribution_file: str = "model_attributions.json"):
        """
        Initialize attribution tracker
        
        Args:
            attribution_file: Path to store attribution data
        """
        self.attribution_file = attribution_file
        self.attributions = self._load_attributions()
        
    def _load_attributions(self) -> Dict[str, Any]:
        """Load existing attributions from file"""
        if os.path.exists(self.attribution_file):
            try:
                with open(self.attribution_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {
            "models": {},
            "contributions": []
        }
        
    def save_attributions(self):
        """Save attributions to file"""
        with open(self.attribution_file, 'w') as f:
            json.dump(self.attributions, f, indent=2, default=str)
            
    def add_contribution(self, model_id: str, task_type: str, 
                        contribution_type: str, reference: str,
                        metadata: Optional[Dict[str, Any]] = None) -> str:
        """
        Add a contribution attribution
        
        Args:
            model_id: Full model identifier (e.g., "TinyLlama/TinyLlama-1.1B-Chat-v1.0")
            task_type: The task type (e.g., "BRAINSTORM_IDEA")
            contribution_type: Type of contribution (e.g., "idea", "code", "review")
            reference: Reference to the contribution (e.g., issue number, file path)
            metadata: Additional metadata
            
        Returns:
            Attribution ID
        """
        attribution_id = f"{model_id.replace('/', '-')}_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        
        # Update model stats
        if model_id not in self.attributions["models"]:
            self.attributions["models"][model_id] = {
                "first_contribution": datetime.now().isoformat(),
                "total_contributions": 0,
                "contributions_by_type": {}
            }
            
        model_stats = self.attributions["models"][model_id]
        model_stats["total_contributions"] += 1
        model_stats["last_contribution"] = datetime.now().isoformat()
        
        if contribution_type not in model_stats["contributions_by_type"]:
            model_stats["contributions_by_type"][contribution_type] = 0
        model_stats["contributions_by_type"][contribution_type] += 1
        
        # Add contribution record
        contribution = {
            "id": attribution_id,
            "model_id": model_id,
            "timestamp": datetime.now().isoformat(),
            "task_type": task_type,
            "contribution_type": contribution_type,
            "reference": reference,
            "metadata": metadata or {}
        }
        
        self.attributions["contributions"].append(contribution)
        self.save_attributions()
        
        return attribution_id
        
    def get_model_stats(self, model_id: str) -> Dict[str, Any]:
        """Get statistics for a specific model"""
        return self.attributions["models"].get(model_id, {})
        
    def get_all_model_stats(self) -> Dict[str, Any]:
        """Get statistics for all models"""
        return self.attributions["models"]
        
    def format_attribution_comment(self, model_id: str, task_type: str,
                                 additional_info: Optional[Dict[str, Any]] = None) -> str:
        """
        Format a GitHub comment for attribution
        
        Args:
            model_id: Model identifier
            task_type: Task type
            additional_info: Additional information to include
            
        Returns:
            Formatted markdown comment
        """
        model_name = model_id.split('/')[-1]
        model_stats = self.get_model_stats(model_id)
        
        comment = f"""## ðŸ¤– Model Attribution

This contribution was generated by: **{model_name}**

### Model Details
- Full Model ID: `{model_id}`
- Task Type: `{task_type}`
- Timestamp: `{datetime.now().isoformat()}`
- Total Contributions by this model: {model_stats.get('total_contributions', 1)}"""

        if additional_info:
            comment += "\n\n### Additional Information"
            for key, value in additional_info.items():
                comment += f"\n- {key}: {value}"
                
        comment += "\n\n---\n*Tracked by llmXive Model Attribution System*"
        
        return comment
        
    def generate_attribution_report(self) -> str:
        """Generate a markdown report of all model contributions"""
        report = """# llmXive Model Attribution Report

This report tracks all contributions made by different models to the llmXive project.

Generated: {timestamp}

## Summary Statistics

| Model | Total Contributions | First Contribution | Last Contribution |
|-------|-------------------|-------------------|-------------------|
""".format(timestamp=datetime.now().isoformat())

        for model_id, stats in self.attributions["models"].items():
            model_name = model_id.split('/')[-1]
            report += f"| {model_name} | {stats['total_contributions']} | {stats['first_contribution'][:10]} | {stats.get('last_contribution', 'N/A')[:10]} |\n"
            
        report += "\n## Contributions by Type\n\n"
        
        for model_id, stats in self.attributions["models"].items():
            model_name = model_id.split('/')[-1]
            report += f"### {model_name}\n\n"
            
            for contrib_type, count in stats.get("contributions_by_type", {}).items():
                report += f"- {contrib_type}: {count}\n"
            report += "\n"
            
        return report
        
    def get_recent_contributions(self, limit: int = 10) -> list:
        """Get recent contributions"""
        # Sort by timestamp descending
        sorted_contribs = sorted(
            self.attributions["contributions"],
            key=lambda x: x["timestamp"],
            reverse=True
        )
        return sorted_contribs[:limit]